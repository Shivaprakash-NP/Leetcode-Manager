### Problem Understanding

The problem asks us to find the `n`-th "ugly number". An ugly number is defined as a positive integer whose prime factors are limited to 2, 3, and 5. The sequence of ugly numbers starts with 1. For example, the first few ugly numbers are 1, 2, 3, 4, 5, 6, 8, 9, 10, 12... (7 is not ugly because its prime factor is 7; 14 is not ugly because its prime factors are 2 and 7).

### Approach / Intuition

The core idea behind solving this problem efficiently is to generate ugly numbers in increasing order using dynamic programming.

1.  **Ordered Generation:** Since we need the `n`-th ugly number, we must generate them sequentially from the first to the `n`-th.
2.  **Dynamic Programming Insight:** Every ugly number (except 1) must be a previous ugly number multiplied by 2, 3, or 5.
    *   For example, 2 = 1\*2, 3 = 1\*3, 4 = 2\*2, 5 = 1\*5, 6 = 2\*3 (or 3\*2), 8 = 4\*2, 9 = 3\*3, 10 = 5\*2, 12 = 6\*2 (or 4\*3).
3.  **Three Pointers (Merging Sorted Streams):** We can maintain three "pointers," each tracking the next candidate ugly number generated by multiplying an existing ugly number by 2, 3, or 5, respectively.
    *   Let `dp` be an array storing the ugly numbers found so far in increasing order.
    *   `pa` points to an index in `dp` such that `dp[pa] * 2` is the next candidate ugly number from the "multiply by 2" stream.
    *   `pb` points to an index in `dp` such that `dp[pb] * 3` is the next candidate ugly number from the "multiply by 3" stream.
    *   `pc` points to an index in `dp` such that `dp[pc] * 5` is the next candidate ugly number from the "multiply by 5" stream.
4.  **Finding the Next Ugly Number:** At each step, the next ugly number will be the minimum of `dp[pa]*2`, `dp[pb]*3`, and `dp[pc]*5`.
5.  **Advancing Pointers:** Once we select a minimum, say `dp[pa]*2`, we increment `pa`. This is because `dp[pa]` has now been used to generate the current ugly number with factor 2, so the *next* candidate from the "multiply by 2" stream will be `dp[pa+1]*2`.
    *   **Crucially:** If the minimum value is generated by *more than one* factor (e.g., 6 can be `dp[pa]*2` if `dp[pa]=3` and `dp[pb]*3` if `dp[pb]=2`), we must increment *all* corresponding pointers (`pa` and `pb` in this example). This prevents adding duplicate ugly numbers to our `dp` array and ensures we consider the next unique candidates.

This approach effectively merges three implicitly sorted lists (ugly numbers \* 2, ugly numbers \* 3, ugly numbers \* 5) to produce a single sorted list of ugly numbers.

### Data Structures and Algorithms

*   **Data Structure:**
    *   `int[] dp`: An array used for dynamic programming to store the ugly numbers found so far in ascending order.
*   **Algorithm:**
    *   **Dynamic Programming:** The solution builds up the `n`-th ugly number by iteratively finding smaller ugly numbers.
    *   **Three-Pointer Approach:** This technique is used to efficiently find the minimum among three candidate values and advance the respective pointers, similar to merging sorted lists.

### Code Walkthrough

```java
class Solution {
    public int nthUglyNumber(int n) {
        // 1. Initialize DP array
        // dp[i] will store the (i+1)-th ugly number.
        int[] dp = new int[n]; 

        // 2. Base case: The first ugly number is always 1.
        dp[0] = 1; 

        // 3. Initialize pointers for factors 2, 3, and 5.
        // These pointers keep track of the index in the 'dp' array 
        // from which we will pick the next ugly number to multiply by 2, 3, or 5.
        int pa = 0; // Pointer for candidates generated by multiplying by 2 (dp[pa] * 2)
        int pb = 0; // Pointer for candidates generated by multiplying by 3 (dp[pb] * 3)
        int pc = 0; // Pointer for candidates generated by multiplying by 5 (dp[pc] * 5)

        // 4. Iterate to fill the dp array from the second ugly number (index 1) up to n-1.
        // We already have dp[0] = 1.
        for(int i = 1; i < n; i++) {
            // 5. Calculate the next potential ugly numbers from each of the three "streams".
            // These are the smallest ugly numbers not yet used to generate a new ugly number,
            // multiplied by their respective factors.
            int nxt_a = dp[pa] * 2; // Candidate from multiplying dp[pa] by 2
            int nxt_b = dp[pb] * 3; // Candidate from multiplying dp[pb] by 3
            int nxt_c = dp[pc] * 5; // Candidate from multiplying dp[pc] by 5

            // 6. Find the minimum among these three candidates.
            // This minimum will be the next ugly number in the sequence.
            int min = Math.min(Math.min(nxt_a, nxt_b), nxt_c);
            dp[i] = min; // Store this new ugly number in our dp array

            // 7. Advance pointers:
            // If the 'min' value was generated by multiplying dp[pa] by 2,
            // we increment 'pa' to consider the next ugly number (dp[pa+1]) for factor 2.
            // We use separate 'if' statements (not 'else if') because it's possible
            // for the same minimum value to be generated by multiple factors.
            // For example, 6 can be 2*3 (from nxt_b) and 3*2 (from nxt_a).
            // In such cases, we must advance all corresponding pointers to avoid duplicates
            // and ensure we move past all instances of the current minimum.
            if(min == nxt_a) pa++; 
            if(min == nxt_b) pb++;
            if(min == nxt_c) pc++;
        }

        // 8. After the loop, dp[n-1] will contain the n-th ugly number.
        return dp[n-1]; 
    }
}
```

### Time and Space Complexity

*   **Time Complexity:** O(N)
    *   The `for` loop runs `n-1` times (from `i = 1` to `n-1`).
    *   Inside the loop, all operations (multiplications, `Math.min` calls, comparisons, and pointer increments) are constant time operations.
    *   Therefore, the total time complexity is directly proportional to `n`.

*   **Space Complexity:** O(N)
    *   An integer array `dp` of size `n` is used to store the ugly numbers.
    *   The space required grows linearly with `n`.