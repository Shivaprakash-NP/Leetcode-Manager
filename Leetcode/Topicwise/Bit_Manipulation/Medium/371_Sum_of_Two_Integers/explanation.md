## Sum of Two Integers Problem and Solution Explanation

This document provides a detailed explanation of the Java code provided for the LeetCode problem "Sum of Two Integers".

### 1. Problem Understanding:

The problem asks us to calculate the sum of two integers, `a` and `b`, *without* using the `+` or `-` operators. This forces us to explore bitwise operations to achieve the desired result.

### 2. Approach / Intuition:

The approach leverages bitwise operations to simulate the addition process at the bit level, mirroring how a full adder circuit works in hardware.  Here's the breakdown:

*   **`a ^ b` (XOR):**  This performs bitwise addition *without* considering the carry. Think of it as calculating the sum of each bit position individually, where 1+0=1, 0+1=1, 0+0=0, and 1+1=0 (carry is ignored).  This is analogous to finding the "sum" output of a half-adder circuit.
*   **`a & b` (AND):** This identifies the bits where *both* `a` and `b` are 1. These positions generate a carry.
*   **`(a & b) << 1` (Left Shift):** The carry generated by the AND operation needs to be added to the next more significant bit.  Therefore, we left-shift the result of `a & b` by one position.

We repeat these steps until there are no more carry bits to add (i.e., `b` becomes 0).

**Why this approach?**

This approach provides a clever way to bypass the standard addition operators and forces us to think about the fundamental bitwise operations involved in addition.  It demonstrates an understanding of how computers perform addition at a low level.

### 3. Data Structures and Algorithms:

*   **Data Structures:** No explicit data structures are used beyond integers.
*   **Algorithms:** The algorithm is based on bitwise operations (XOR, AND, Left Shift) and a `while` loop for iterative carry propagation. This can be considered a bit manipulation algorithm.

### 4. Code Walkthrough:

```java
class Solution {
    public int getSum(int a, int b) {
        while(b != 0)
        {
            int t = (a&b)<<1;
            a = a^b;
            b = t;
        }
        return a;
    }
}
```

1.  **`class Solution { ... }`**:  This defines a class named `Solution`, standard for LeetCode problem submissions.
2.  **`public int getSum(int a, int b) { ... }`**: This is the method that accepts two integers, `a` and `b`, as input and returns their sum (calculated without using `+` or `-`).
3.  **`while(b != 0) { ... }`**: This loop continues as long as `b` is not zero.  `b` represents the carry bits.  The loop iterates until there are no more carry bits to process.
4.  **`int t = (a&b)<<1;`**:
    *   `a & b`:  Calculates the bitwise AND of `a` and `b`. This identifies the bits where a carry will be generated.
    *   `<< 1`: Left-shifts the result by one position. This moves the carry bits to the next higher bit position, ready to be added in the next iteration.
    *   `int t = ...`: The result is stored in a temporary variable `t`.  `t` holds the carries to be added in the next iteration.
5.  **`a = a^b;`**:  Calculates the bitwise XOR of `a` and `b`. This performs the addition without considering the carry. The result is stored back in `a`. `a` now holds the sum of `a` and `b` excluding the carries.
6.  **`b = t;`**: Assigns the value of `t` (the carry bits shifted to the next position) to `b`.  In the next iteration, `b` will be XORed with `a` to incorporate the carry into the running sum.
7.  **`return a;`**: Once the `while` loop finishes (when `b` becomes 0, meaning there are no more carries), the value of `a` contains the complete sum of the original `a` and `b`. The method returns this sum.

**Example:**

Let's say `a = 2` (binary `0010`) and `b = 3` (binary `0011`).

*   **Iteration 1:**
    *   `t = (a & b) << 1 = (0010 & 0011) << 1 = (0010) << 1 = 0100`
    *   `a = a ^ b = 0010 ^ 0011 = 0001`
    *   `b = t = 0100`
*   **Iteration 2:**
    *   `t = (a & b) << 1 = (0001 & 0100) << 1 = (0000) << 1 = 0000`
    *   `a = a ^ b = 0001 ^ 0100 = 0101`
    *   `b = t = 0000`
*   The loop terminates because `b` is now 0.
*   `a` is now `0101`, which is 5 in decimal.  This is the correct sum of 2 and 3.

### 5. Time and Space Complexity:

*   **Time Complexity:** The time complexity is O(log n), where n is the larger of the two input numbers.  The `while` loop iterates a number of times proportional to the number of bits required to represent the numbers. In the worst-case scenario (e.g., adding two large numbers), the loop iterates as many times as there are bits in the larger number. Thus the logarithmic time complexity is derived.
*   **Space Complexity:** The space complexity is O(1). The algorithm uses a constant amount of extra space (only a few integer variables like `t`) regardless of the input values. The space used does not scale with the input.
